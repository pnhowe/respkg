#!/usr/bin/python -u
import sys
import os
import optparse
import subprocess
import hashlib

from respkg import RespkgBuilder, RespkgReader, RespkgManager, __VERSION__

INIT_FILE_PATH = '/tmp/respkg.init'

oparser = optparse.OptionParser( description='respkg installer/manager/builder, version: %s' % __VERSION__ )
oparser.add_option( '-y', '--yes', help='Assume "yes" for Questions', action='store_true' )

ogroup = optparse.OptionGroup( oparser, 'Package Building', 'name(-n) and version(-v) are required.' )
ogroup.add_option( '-b', '--build', help='Build new respkg ( name, version, description required )', dest='build', metavar='FILENAME' )
ogroup.add_option( '-n', '--name', help='Name of Package, must be a single word', dest='name' )
ogroup.add_option( '-e', '--version', help='Version of Package', dest='version' )
ogroup.add_option( '-c', '--description', help='Description of Package', dest='description' )
ogroup.add_option( '-t', '--init-script', help='Init Script File', dest='init_script', metavar='FILENAME' )
ogroup.add_option( '-d', '--data', help='Package Data/Contense root directory', dest='data', metavar='DIRNAME' )
ogroup.add_option( '-f', '--conflicts-with', help='Package that cannot be installed if this one is (can be specified more than once)', metavar='PACKAGENAME', dest='conflicts_with', action='append' )
oparser.add_option_group( ogroup )

ogroup = optparse.OptionGroup( oparser, 'Package Installing', 'Install from local file with install(-i) or from a JSON repo with from-repo(-r)' )
ogroup.add_option( '-r', '--from-repo', help='Install from repo, followed by package name, and optionally version, (example: respkg -r myrepo mypackage [version])', dest='repo' )
ogroup.add_option( '-i', '--install', help='Install respkg', dest='install', metavar='FILENAME' )
ogroup.add_option( '-a', '--target-dir', help='Target Directory to install to (default: /)', dest='target_dir', default='/' )
oparser.add_option_group( ogroup )

ogroup = optparse.OptionGroup( oparser, 'Other Utilities', '' )
ogroup.add_option( '-l', '--list', help='List Installed Packages', dest='list', action='store_true' )
ogroup.add_option( '--add-repo', help='Add Repo, followed by repo name, url for the repo, component, and optionally the proxy, url is the path to the location where the _repo_<component> is directory located. (example: respkg --add-repo myrepo http://repo/url mycomponent [proxy] )', dest='add_repo', action='store_true' )
ogroup.add_option( '--set-key', help='Add Public Key to Repo, followed by repo name, then the repos signing key, signing key may be "-" to read from from stdin', dest='set_key', action='store_true' )
ogroup.add_option( '--check-installed', help='Verify the Checksums of the locally installed files', dest='check_installed', action='store_true' )
oparser.add_option_group( ogroup )

( options, args ) = oparser.parse_args()

# do build first, it's dosen't require manager, so don't leave the db behind

def _continue_prompt():
  if options.yes:
    return True

  if not sys.stdin.isatty() or not sys.stdout.isatty(): # non interactive, fail
    return False

  tmp = raw_input( 'Continue? (Y/N):' )
  if tmp.lower() == 'y':
    return True

  else:
    return False

def _updatesha( package, file_path ):
  sha256 = hashlib.sha256()
  sha256.update( open( file_path, 'r' ).read() )
  manager.setFileSum( package, file_path, sha256.hexdigest() )


def _install_file( file_name, target_dir, manager ):
  if not os.path.isdir( target_dir ):
    print 'Target dir "%s" does not exist or is not a directory.' % target_dir
    return False

  target_dir = os.path.realpath( target_dir )

  reader = RespkgReader( file_name )

  conflict_list = set( reader.conflicts ) & set( manager.getInstalledPackages() )
  if conflict_list:
    print 'ERROR: this package conflicts with these allready installed packages:'
    print '\n'.join( conflict_list )
    print 'Bailing.'
    return False

  prev = manager.getPackage( reader.name )
  if prev:
    if prev[ 'version' ] > reader.version:
      print 'WARNING: Previosully install package has a greater version number.'
      if not _continue_prompt():
        print 'Bailing.'
        return False

    if target_dir != prev[ 'target_dir' ]:
      print 'WARNING: Installing to diffrent target directory than last time.'
      print 'Previous Install Location: "%s"' % prev[ 'target_dir' ]
      print 'Curent Install Location: "%s"' % target_dir
      if not _continue_prompt():
        print 'Bailing.'
        return False

  else:
    prev = { 'version': '*NEW*' }

  if prev[ 'version' ] != reader.version:
    print 'Upgrading from "%s" to "%s"' % ( prev[ 'version' ], reader.version )
  else:
    print 'Re-Installing versino "%s"' % reader.version

  filename_list = reader.getFileList()

  installed_list = manager.getInstalledFiles( reader.name )

  common_list = set( filename_list ) & set( installed_list )
  if common_list:
    print 'ERROR: these files are allready installed by another package:'
    print '\n'.join( common_list )
    print 'Bailing.'
    return False

  init = open( INIT_FILE_PATH, 'w' )
  init.write( reader.readInit() )
  init.close()
  os.chmod( INIT_FILE_PATH, 0755 )

  reader.extract( target_dir, _updatesha )

  rc = subprocess.call( [ INIT_FILE_PATH, target_dir, reader.version, prev[ 'version' ] ] )
  os.unlink( INIT_FILE_PATH )

  if rc != 0:
    print 'WARNING: init returned %s' % rc
    return False

  manager.packageInstalled( reader.name, reader.version, reader.description, reader.created, options.target_dir )

  return True


if options.build:
  if not options.name or not options.data or not options.version:
    oparser.error( 'No Name, Data, or Version Specified' )
    sys.exit( 1 )

  if options.init_script and not os.path.isfile( options.init_script ):
    print 'Init Script "%s" does not exists or is not a file.' % options.init_script
    sys.exit( 1 )

  if not os.path.isdir( options.data ):
    print 'Data "%s" is not a directory.' % options.data
    sys.exit( 1 )

  if not options.description or not options.init_script:
    print 'WARNING: Description and/or Init Script not Specified'
    if not _continue_prompt():
      print 'Bailing.'
      sys.exit( 1 )

  builder = RespkgBuilder()
  builder.data = options.data
  builder.name = options.name
  builder.version = options.version
  builder.description = options.description
  if options.conflicts_with:
    builder.conflicts = options.conflicts_with

  if options.init_script:
    builder.setInit( open( options.init_script, 'r' ).read() )

  builder.write( options.build )

  sys.exit( 0 )

# all these options require the manager, I guess we can create the db now

manager = RespkgManager()


if options.list:
  repo_map = manager.repoList()
  print 'Repo\tURL\tComponent\tProxy\tHas Key'
  for repo in repo_map:
    item = repo_map[ repo ]
    print '%s\t%s\t%s\t%s\t%s' % ( repo, item[ 'url' ], item[ 'component'], item[ 'proxy' ], item[ 'has_key' ] )

  print

  package_map = manager.packageList()
  print 'Package\tVersion\tInstalled\t\tPkg Created\t\tTarget Dir\tDescription'
  for package in package_map:
    item = package_map[ package ]
    print '%s\t%s\t%s\t%s\t%s\t%s' % ( package, item[ 'version' ], item[ 'installed' ], item[ 'pkg_created' ], item[ 'target_dir' ], item[ 'description' ] )

  sys.exit( 0 )


if options.check_installed:
  file_list = manager.getFileChecksums()
  for filename in file_list:
    sha256 = hashlib.sha256()
    sha256.update( open( filename, 'r' ).read() )
    print '%s\t%s' % ( filename, 'Good' if sha256.hexdigest() == file_list[ filename ] else 'Bad' )

  sys.exit( 0 )

if options.add_repo:
  if len( args ) < 3:
    oparser.error( 'Repo Name, URL, component are required' )
    sys.exit( 1 )

  try:
    proxy = args[3]
  except IndexError:
    proxy = None

  manager.addRepo( args[0], args[1], args[2], proxy )

  sys.exit( 0 )


if options.set_key:
  pub_key = ''
  keyfile = args[1]

  if keyfile == '-':
    pub_key = sys.stdin.read()

  else:
    if not os.path.isfile( keyfile ):
      print 'Key File "%s" does not exist or is not a file.' % keyfile
      sys.exit( 1 )

    pub_key = open( keyfile, 'r' ).read()

  manager.setKey( args[0], pub_key )


if options.repo:
  if len( args ) < 1:
    oparser.error( 'Package Name(s) are required' )
    sys.exit( 1 )

  try:
    version = args[3]
  except IndexError:
    version = None

  for package in args:
    tempfile = manager.getPackageFile( options.repo, package, version )
    if tempfile is None:
      print 'Error installing from repo'
      sys.exit( 1 )

    rc = _install_file( tempfile, options.target_dir, manager )
    os.unlink( tempfile )

  if not rc:
    sys.exit( 1 )

  sys.exit( 0 )


if options.install:
  if not os.path.isfile( options.install ):
    print 'Package "%s" is does not exist or is not a file.' % options.install
    sys.exit( 1 )

  if not _install_file( options.install, options.target_dir, manager ):
    sys.exit( 1 )

  sys.exit( 0 )

oparser.print_help()
sys.exit( 1 )
